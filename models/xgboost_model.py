import pickle
import xgboost as xgb
from sklearn.model_selection import StratifiedKFold, GridSearchCV
from sklearn.metrics import accuracy_score, f1_score
from utils import save_result



class XgbModel(object):
    
    def __init__(self):
        '''
        The constructor.
        '''
        self._model = None
        self._modelfile = None
        self._bestparams = {}
        
    @classmethod
    def from_weights(cls, modelfile):
        '''
        Alternate constructor of XgbModel class.
        Load an existing Xgb model from 'modelfile'.
        
        :param modelfile: an existing Xgb model
        :return: an instance of XgbModel class.
        '''
        
        self = cls()
        self._model = pickle.load(open(modelfile, 'rb'))
        self._modelfile = modelfile
        return self
    
    @classmethod
    def from_params(cls, X_train, y_train,
                num_folds, param_grid,
                scoring, seed):
        '''
        Alternate constructor of XgbModel class.
        Create a instance of XgbModel class with parameters obtained
        after having performed cross-validation on parameters supplied in 'param_grid'
        
        :param X_train: input training data
        :param y_train: output training data
        :param num_folds: the number of fold for cross-validation
        :param param_grid: a dictionary of parameters
        :param scoring: a list of scoring methods
        :param seed: a sedd
        :return: An instance of XgbModel class
        '''
        self = cls()
        _, self._bestparams = self.search_xgb_params(X_train, y_train,
                num_folds, param_grid,
                scoring, seed)
        self._model = xgb.XGBClassifier(nthread=-1, **self._bestparams)
        return self
    
    def search_xgb_params(self, X_train, y_train,
                num_folds, param_grid,
                scoring, seed):
        '''
        Perform a k-folds cross-validation to find the best parameters in 'param_grid' for the model.
        
        :param X_train: input training data.
        :param y_train: output training data.
        :param num_folds: the number of folds.
        :param param_grid: a dict of parameters.
        :param scoring: the scoring methods.
        :param seed: the seed
        :return: Tuple of:  best score and best parameters
        '''

        model = xgb.XGBClassifier(n_thread=-1)
        kfold = StratifiedKFold(n_splits=num_folds, shuffle=True, random_state=seed)
        grid_search = GridSearchCV(model, param_grid=param_grid, scoring=scoring, n_jobs=-1, verbose=10, cv=kfold)
        grid_result = grid_search.fit(X_train, y_train)
        best_params = grid_result.best_params_
        best_score = grid_result.best_score_
        results = []
        mean_test_score = grid_result.cv_results_['mean_test_score']
        mean_train_score = grid_result.cv_results_['mean_train_score']
        for i, elt in enumerate(grid_result.cv_results_['params']):
            elt['mean_test_score'] = mean_test_score[i]
            elt['mean_train_score'] = mean_train_score[i]
            results.append(elt)
        save_result('/output/results.csv', results)
        return best_score, best_params
        
    def train(self, X_train, y_train):
        '''
        Train the model.
        :param X_train: input training data
        :param y_train: output training data
        :return: None
        '''
        #if not self._model:
        self._model.fit(X_train, y_train)
            
    
    def evaluate(self, y_test, predictions):
        '''
        Evaluate the model on the test data.
        :param y_test: Actual output.
        :param predictions: the predictions generated by our model
        :return: accuracy and f1 score
        '''
        accuracy = accuracy_score(y_test, predictions)
        f1 = f1_score(y_test, predictions)
        
        return accuracy, f1
    
    def predict(self, X):
        '''
        Perform prediction on new data.
        :param X: the input data
        :return: the predictions
        '''
        
        y_pred = self._model.predict(X)
        return y_pred
